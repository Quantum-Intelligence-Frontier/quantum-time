<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>quarto-inputf6a9dbc0577b58f6 – Quantum Time &amp; History</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-f507c7d0488cb7630e20aad62ad8c2aa.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>window.MathJax = {loader: {load: ['[tex]/boldsymbol']},tex: {packages: {'[+]': ['boldsymbol']}}};</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notebooks/ko/1장.힐베르트공간과_내적_연산자이론.html">본문</a></li><li class="breadcrumb-item"><a href="../../notebooks/ko/14.부록.html">14. 부록</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">한국어</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Language</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index_en.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">English</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">한국어</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/0.목차.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">목차</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">본문</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/1장.힐베르트공간과_내적_연산자이론.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1장. 힐베르트공간과 내적 연산자이론</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/2장.양자_시스템의_결합과_상태.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2장. 양자 시스템의 결합과 상태</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/3장.대칭_군_그리고_생성자.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3장. 대칭 군 그리고 생성자</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/4장.작용_함수적과_변분_오일러-라그랑주_방정식.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4장. 작용 함수적과 변분 오일러-라그랑주 방정식</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/5장.경로적분_공리화_범함수_적분_기호.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5장. 경로적분 공리화 범함수 적분 기호</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/6장.열린_양자시스템의_동역학.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6장. 열린 양자시스템의 동역학</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/7장.일관성_역사와_양자적_확률.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7장. 일관성 역사와 양자적 확률</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/8장.자연선택과_양자_지우개.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8장. 자연선택과 양자 지우개</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/9장.양자다원주의_객관적_실재는_어떻게_탄생하는가.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9장. 양자다원주의 객관적 실재는 어떻게 탄생하는가</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/10장.창발적_시간-정지된_우주_속_시간의_흐름_Page-Wootters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">10장. 창발적 시간 - 정지된 우주 속 시간의 흐름 Page-Wootters</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/11장.C-von_Neumann_연산자대수_열적_시간.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11장. C-von Neumann 연산자대수 열적 시간</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/12장.불확정_인과_순서.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">12장. 불확정 인과 순서</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/13장.레게트-가르그_부등식-시간_속_숨겨진_양자성.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">13장. 레게트-가르그 부등식 - 시간 속 숨겨진 양자성</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notebooks/ko/14.부록.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">14. 부록</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#부록-1-양자역학을-위한-선형대수-기초" id="toc-부록-1-양자역학을-위한-선형대수-기초" class="nav-link active" data-scroll-target="#부록-1-양자역학을-위한-선형대수-기초">부록 1: 양자역학을 위한 선형대수 기초</a>
  <ul class="collapse">
  <li><a href="#선형성-벡터-함수-그리고-연산자" id="toc-선형성-벡터-함수-그리고-연산자" class="nav-link" data-scroll-target="#선형성-벡터-함수-그리고-연산자">1. 선형성: 벡터, 함수, 그리고 연산자</a></li>
  <li><a href="#헤르미트-연산자-관측가능량" id="toc-헤르미트-연산자-관측가능량" class="nav-link" data-scroll-target="#헤르미트-연산자-관측가능량">2. 헤르미트 연산자 (관측가능량)</a></li>
  <li><a href="#브라-캣bra-ket-표기법과-기대값" id="toc-브라-캣bra-ket-표기법과-기대값" class="nav-link" data-scroll-target="#브라-캣bra-ket-표기법과-기대값">3. 브라-캣(Bra-Ket) 표기법과 기대값</a></li>
  <li><a href="#기초-연습문제" id="toc-기초-연습문제" class="nav-link" data-scroll-target="#기초-연습문제">4. 기초 연습문제</a></li>
  </ul></li>
  <li><a href="#부록-2-신규-고전-확률과-양자-확률" id="toc-부록-2-신규-고전-확률과-양자-확률" class="nav-link" data-scroll-target="#부록-2-신규-고전-확률과-양자-확률">부록 2: (신규) 고전 확률과 양자 확률</a>
  <ul class="collapse">
  <li><a href="#고전-확률-주사위-던지기" id="toc-고전-확률-주사위-던지기" class="nav-link" data-scroll-target="#고전-확률-주사위-던지기">1. 고전 확률 (주사위 던지기 🎲)</a></li>
  <li><a href="#양자-확률-양자-동전" id="toc-양자-확률-양자-동전" class="nav-link" data-scroll-target="#양자-확률-양자-동전">2. 양자 확률 (양자 동전 🪙)</a></li>
  <li><a href="#결정적-차이-무지인가-중첩인가" id="toc-결정적-차이-무지인가-중첩인가" class="nav-link" data-scroll-target="#결정적-차이-무지인가-중첩인가">3. 결정적 차이: ’무지’인가, ’중첩’인가?</a></li>
  </ul></li>
  <li><a href="#부록-3-표기법-가이드" id="toc-부록-3-표기법-가이드" class="nav-link" data-scroll-target="#부록-3-표기법-가이드">부록 3: 표기법 가이드</a>
  <ul class="collapse">
  <li><a href="#선형대수-표기-d_mathcalp_n" id="toc-선형대수-표기-d_mathcalp_n" class="nav-link" data-scroll-target="#선형대수-표기-d_mathcalp_n">1. 선형대수 표기: <span class="math inline">\([D]_{\mathcal{P}_n}\)</span></a></li>
  <li><a href="#대괄호-가-흔히-쓰이는-경우" id="toc-대괄호-가-흔히-쓰이는-경우" class="nav-link" data-scroll-target="#대괄호-가-흔히-쓰이는-경우">2. 대괄호 <code>[ ]</code>가 흔히 쓰이는 경우</a></li>
  </ul></li>
  <li><a href="#부록-4-군의-분류-체계-u-s-o-그리고-그-너머" id="toc-부록-4-군의-분류-체계-u-s-o-그리고-그-너머" class="nav-link" data-scroll-target="#부록-4-군의-분류-체계-u-s-o-그리고-그-너머">부록 4: 군의 분류 체계: U, S, O, 그리고 그 너머</a>
  <ul class="collapse">
  <li><a href="#근본적인-분류-이산-군-vs.-연속-군" id="toc-근본적인-분류-이산-군-vs.-연속-군" class="nav-link" data-scroll-target="#근본적인-분류-이산-군-vs.-연속-군">1. 근본적인 분류: 이산 군 vs.&nbsp;연속 군</a></li>
  <li><a href="#속성property에-따른-분류-the-s-u-o-hierarchy" id="toc-속성property에-따른-분류-the-s-u-o-hierarchy" class="nav-link" data-scroll-target="#속성property에-따른-분류-the-s-u-o-hierarchy">2. 속성(Property)에 따른 분류 (The S, U, O Hierarchy)</a></li>
  <li><a href="#위상topology에-따른-분류-물리학과-무관해-보이지만-결정적인-기준" id="toc-위상topology에-따른-분류-물리학과-무관해-보이지만-결정적인-기준" class="nav-link" data-scroll-target="#위상topology에-따른-분류-물리학과-무관해-보이지만-결정적인-기준">3. 위상(Topology)에 따른 분류 (물리학과 무관해 보이지만 결정적인 기준)</a></li>
  <li><a href="#대수algebra에-따른-분류-단순성" id="toc-대수algebra에-따른-분류-단순성" class="nav-link" data-scroll-target="#대수algebra에-따른-분류-단순성">4. 대수(Algebra)에 따른 분류 (단순성)</a></li>
  </ul></li>
  <li><a href="#부록-5-핵심-학습-로드맵-및-전략" id="toc-부록-5-핵심-학습-로드맵-및-전략" class="nav-link" data-scroll-target="#부록-5-핵심-학습-로드맵-및-전략">부록 5: 핵심 학습 로드맵 및 전략</a>
  <ul class="collapse">
  <li><a href="#단계-핵심-로드맵" id="toc-단계-핵심-로드맵" class="nav-link" data-scroll-target="#단계-핵심-로드맵">1. 4단계 핵심 로드맵</a></li>
  <li><a href="#권장-학습-전략" id="toc-권장-학습-전략" class="nav-link" data-scroll-target="#권장-학습-전략">2. 권장 학습 전략 💡</a></li>
  <li><a href="#확장성-양자-우주론" id="toc-확장성-양자-우주론" class="nav-link" data-scroll-target="#확장성-양자-우주론">3. 확장성: 양자 우주론 🌌</a></li>
  </ul></li>
  <li><a href="#부록-6-이-책의-위상과-다음-단계" id="toc-부록-6-이-책의-위상과-다음-단계" class="nav-link" data-scroll-target="#부록-6-이-책의-위상과-다음-단계">부록 6: 이 책의 위상과 다음 단계</a>
  <ul class="collapse">
  <li><a href="#학문-영역별-커버리지" id="toc-학문-영역별-커버리지" class="nav-link" data-scroll-target="#학문-영역별-커버리지">1. 학문 영역별 커버리지</a></li>
  <li><a href="#양자-우주론으로-나아가기" id="toc-양자-우주론으로-나아가기" class="nav-link" data-scroll-target="#양자-우주론으로-나아가기">2. 양자 우주론으로 나아가기</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notebooks/ko/1장.힐베르트공간과_내적_연산자이론.html">본문</a></li><li class="breadcrumb-item"><a href="../../notebooks/ko/14.부록.html">14. 부록</a></li></ol></nav></header>




<hr style="border-top: 3px double #333;">
<section id="부록-1-양자역학을-위한-선형대수-기초" class="level2">
<h2 class="anchored" data-anchor-id="부록-1-양자역학을-위한-선형대수-기초">부록 1: 양자역학을 위한 선형대수 기초</h2>
<p>이 부록은 1장의 핵심 개념인 선형 연산자, 헤르미트 연산자, 브라-캣 표기법을 초보자의 눈높이에서 보충 설명합니다.</p>
<section id="선형성-벡터-함수-그리고-연산자" class="level3">
<h3 class="anchored" data-anchor-id="선형성-벡터-함수-그리고-연산자">1. 선형성: 벡터, 함수, 그리고 연산자</h3>
<p>선형대수의 핵심은 <strong>“선형성(Linearity)”</strong>입니다. 이는 “더한 것의 변환”이 “각각의 변환을 더한 것”과 같다는 뜻입니다.</p>
<ul>
<li><span class="math inline">\(L(a\vec{v} + b\vec{w}) = a L(\vec{v}) + b L(\vec{w})\)</span></li>
</ul>
<p>우리는 보통 <span class="math inline">\(L\)</span>을 행렬, <span class="math inline">\(\vec{v}\)</span>를 열벡터로 배우지만, 양자역학에서는 이 개념이 확장됩니다.</p>
<ul>
<li><strong>벡터 (<span class="math inline">\(|\psi\rangle\)</span>):</strong> 상태. (예: <span class="math inline">\(\begin{pmatrix} a \\ b \end{pmatrix}\)</span>)</li>
<li><strong>벡터 공간:</strong> 함수들의 집합. (예: <span class="math inline">\(L^2[0,1]\)</span>, 1장에서 배운 제곱 적분 가능 함수)</li>
<li><strong>선형 연산자 (<span class="math inline">\(\hat{A}\)</span>):</strong> 행렬 <strong>또는</strong> 미분 연산자.</li>
</ul>
<p><strong>미분 연산자가 왜 선형인가?</strong> 미분 연산자 <span class="math inline">\(\frac{d}{dx}\)</span>는 두 함수 <span class="math inline">\(f(x), g(x)\)</span>와 스칼라 <span class="math inline">\(a, b\)</span>에 대해 다음을 만족합니다.</p>
<p><span class="math display">\[
\frac{d}{dx}[a f(x) + b g(x)] = a \frac{d f(x)}{dx} + b \frac{d g(x)}{dx}
\]</span></p>
<p>이는 선형성의 정의와 정확히 일치합니다. 따라서 미분 연산자(<span class="math inline">\(\frac{d}{dx}\)</span>)도 함수라는 벡터 공간에서 작동하는 ’연산자’이며, 힐베르트 공간 이론으로 다룰 수 있습니다.</p>
</section>
<section id="헤르미트-연산자-관측가능량" class="level3">
<h3 class="anchored" data-anchor-id="헤르미트-연산자-관측가능량">2. 헤르미트 연산자 (관측가능량)</h3>
<p>물리적 세계에서 우리가 측정하는 값(위치, 운동량, 에너지)은 항상 <strong>실수</strong>입니다. 양자역학에서는 이러한 ’관측가능량’을 <strong>헤르미트(Hermitian) 연산자</strong>로 표현합니다.</p>
<ul>
<li><p><strong>정의:</strong> 연산자 <span class="math inline">\(\hat{A}\)</span>의 켤레 전치(<span class="math inline">\(\dagger\)</span>, “대거”)가 자기 자신과 같은 경우 <span class="math display">\[\hat{A} = \hat{A}^\dagger\]</span> (<span class="math inline">\(\hat{A}^\dagger\)</span>는 행렬의 모든 원소를 복소켤레(<span class="math inline">\(\overline{a+ib} = a-ib\)</span>)한 뒤, 행과 열을 뒤집은(전치) 것입니다.)</p></li>
<li><p><strong>핵심 성질:</strong></p>
<ol type="1">
<li><strong>고유값은 항상 실수이다:</strong> 이 성질 덕분에 헤르미트 연산자의 측정값이 항상 실수임을 보장받습니다.</li>
<li><strong>서로 다른 고유벡터는 항상 직교한다:</strong> 이는 우리가 세상을 ‘이것’ 아니면 ’저것’으로 명확히 구분하여 측정할 수 있는 수학적 기반(직교 기저)을 제공합니다.</li>
</ol></li>
<li><p><strong>예제:</strong></p>
<ul>
<li><strong>실수 대칭:</strong> <span class="math inline">\(A = \begin{pmatrix} 2 &amp; 1 \\ 1 &amp; 3 \end{pmatrix} \implies A^\dagger = \begin{pmatrix} 2 &amp; 1 \\ 1 &amp; 3 \end{pmatrix}^\mathsf{T} = A\)</span> (헤르미트)</li>
<li><strong>복소수:</strong> <span class="math inline">\(B = \begin{pmatrix} 1 &amp; i \\ -i &amp; 4 \end{pmatrix} \implies B^\dagger = \overline{\begin{pmatrix} 1 &amp; -i \\ i &amp; 4 \end{pmatrix}}^\mathsf{T} = \begin{pmatrix} 1 &amp; i \\ -i &amp; 4 \end{pmatrix} = B\)</span> (헤르미트)</li>
<li><strong>비-헤르미트:</strong> <span class="math inline">\(C = \begin{pmatrix} 0 &amp; i \\ i &amp; 0 \end{pmatrix} \implies C^\dagger = \overline{\begin{pmatrix} 0 &amp; i \\ i &amp; 0 \end{pmatrix}}^\mathsf{T} = \begin{pmatrix} 0 &amp; -i \\ -i &amp; 0 \end{pmatrix} \neq C\)</span></li>
</ul></li>
</ul>
</section>
<section id="브라-캣bra-ket-표기법과-기대값" class="level3">
<h3 class="anchored" data-anchor-id="브라-캣bra-ket-표기법과-기대값">3. 브라-캣(Bra-Ket) 표기법과 기대값</h3>
<p>디랙(Dirac) 표기법은 선형대수 계산을 매우 직관적으로 만듭니다.</p>
<ul>
<li><strong>캣 (Ket) <span class="math inline">\(|\psi\rangle\)</span>:</strong> 열벡터 (상태) <span class="math display">\[|\psi\rangle = \begin{pmatrix} a \\ b \end{pmatrix}\]</span></li>
<li><strong>브라 (Bra) <span class="math inline">\(\langle\psi|\)</span>:</strong> 캣의 <strong>에르미트 수반</strong> (행벡터) <span class="math display">\[\langle\psi| = |\psi\rangle^\dagger = \overline{\begin{pmatrix} a \\ b \end{pmatrix}}^\mathsf{T} = \begin{pmatrix} \bar{a} &amp; \bar{b} \end{pmatrix}\]</span></li>
</ul>
<p><strong>주요 연산:</strong></p>
<ol type="1">
<li><p><strong>내적 (Overlap): <span class="math inline">\(\langle\phi|\psi\rangle\)</span></strong> “브라”와 “캣”을 곱하면 스칼라(복소수)가 나옵니다. <span class="math display">\[\langle\phi|\psi\rangle = \begin{pmatrix} \bar{c} &amp; \bar{d} \end{pmatrix} \begin{pmatrix} a \\ b \end{pmatrix} = \bar{c}a + \bar{d}b\]</span></p></li>
<li><p><strong>기대값 (Expectation Value): <span class="math inline">\(\langle\psi|\hat{A}|\psi\rangle\)</span></strong> 상태 <span class="math inline">\(|\psi\rangle\)</span>에서 관측량 <span class="math inline">\(\hat{A}\)</span>를 측정할 때의 평균값입니다. <span class="math display">\[\langle\psi|\hat{A}|\psi\rangle = \begin{pmatrix} \bar{a} &amp; \bar{b} \end{pmatrix} \begin{pmatrix} A_{11} &amp; A_{12} \\ A_{21} &amp; A_{22} \end{pmatrix} \begin{pmatrix} a \\ b \end{pmatrix}\]</span> <em>만약 <span class="math inline">\(\hat{A}\)</span>가 헤르미트 연산자라면, 이 계산 결과는 항상 <strong>실수</strong>가 됩니다.</em></p></li>
<li><p><strong>외부곱 (Outer Product): <span class="math inline">\(|\psi\rangle\langle\phi|\)</span></strong> “캣”과 “브라”를 곱하면 <strong>연산자(행렬)</strong>가 됩니다. <span class="math display">\[|\psi\rangle\langle\phi| = \begin{pmatrix} a \\ b \end{pmatrix} \begin{pmatrix} \bar{c} &amp; \bar{d} \end{pmatrix} = \begin{pmatrix} a\bar{c} &amp; a\bar{d} \\ b\bar{c} &amp; b\bar{d} \end{pmatrix}\]</span></p>
<ul>
<li>특히 <span class="math inline">\(|\psi\rangle\langle\psi|\)</span>는 <span class="math inline">\(|\psi\rangle\)</span> 방향으로의 <strong>투영 연산자(프로젝터)</strong>입니다.</li>
</ul></li>
</ol>
</section>
<section id="기초-연습문제" class="level3">
<h3 class="anchored" data-anchor-id="기초-연습문제">4. 기초 연습문제</h3>
<p><strong>문제 1: 헤르미트 판별</strong> 다음 행렬이 헤르미트인지 판별하시오. <span class="math inline">\(A=\begin{pmatrix}2&amp;1+i\\1-i&amp;3\end{pmatrix} \quad B=\begin{pmatrix}1&amp;2\\3&amp;4\end{pmatrix}\)</span></p>
<blockquote class="blockquote">
<p><strong>풀이:</strong> <span class="math inline">\(A^\dagger = \overline{\begin{pmatrix} 2 &amp; 1-i \\ 1+i &amp; 3 \end{pmatrix}}^\mathsf{T} = \begin{pmatrix} 2 &amp; 1+i \\ 1-i &amp; 3 \end{pmatrix} = A\)</span>. (헤르미트 O) <span class="math inline">\(B^\dagger = \overline{\begin{pmatrix} 1 &amp; 3 \\ 2 &amp; 4 \end{pmatrix}}^\mathsf{T} = \begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{pmatrix} = B\)</span>. (헤르미트 O, 실수 대칭 행렬) <em>(이전 원본 <span class="math inline">\(C\)</span> 행렬은 실수 대칭이 아니었으나, <span class="math inline">\(B\)</span>로 수정된 버전은 실수 대칭이므로 헤르미트입니다.)</em></p>
</blockquote>
<p><strong>문제 2: 기대값 계산 (실수 확인)</strong> 상태 <span class="math inline">\(|\psi\rangle = \frac{1}{\sqrt{5}}\begin{pmatrix} 1 \\ 2i \end{pmatrix}\)</span>와 연산자 <span class="math inline">\(\hat{A} = \begin{pmatrix} 1 &amp; i \\ -i &amp; 1 \end{pmatrix}\)</span>에 대해 기대값 <span class="math inline">\(\langle\psi|\hat{A}|\psi\rangle\)</span>를 계산하시오.</p>
<blockquote class="blockquote">
<p><strong>풀이:</strong> 1. 브라 계산: <span class="math inline">\(\langle\psi| = \frac{1}{\sqrt{5}}\begin{pmatrix} 1 &amp; -2i \end{pmatrix}\)</span> 2. <span class="math inline">\(\hat{A}|\psi\rangle\)</span> 계산: <span class="math inline">\(\frac{1}{\sqrt{5}} \begin{pmatrix} 1 &amp; i \\ -i &amp; 1 \end{pmatrix} \begin{pmatrix} 1 \\ 2i \end{pmatrix} = \frac{1}{\sqrt{5}} \begin{pmatrix} 1 + (i)(2i) \\ (-i)(1) + (1)(2i) \end{pmatrix} = \frac{1}{\sqrt{5}} \begin{pmatrix} 1 - 2 \\ -i + 2i \end{pmatrix} = \frac{1}{\sqrt{5}} \begin{pmatrix} -1 \\ i \end{pmatrix}\)</span> 3. <span class="math inline">\(\langle\psi|(\hat{A}|\psi\rangle)\)</span> 계산: <span class="math inline">\(\frac{1}{\sqrt{5}}\begin{pmatrix} 1 &amp; -2i \end{pmatrix} \cdot \frac{1}{\sqrt{5}} \begin{pmatrix} -1 \\ i \end{pmatrix} = \frac{1}{5} ( (1)(-1) + (-2i)(i) ) = \frac{1}{5} ( -1 - 2i^2 ) = \frac{1}{5} ( -1 + 2 ) = \frac{1}{5}\)</span></p>
<p><span class="math inline">\(\hat{A}\)</span>는 헤르미트 연산자이며, 기대값 <span class="math inline">\(\frac{1}{5}\)</span>은 실수가 나왔습니다.</p>
</blockquote>
<hr>
</section>
</section>
<section id="부록-2-신규-고전-확률과-양자-확률" class="level2">
<h2 class="anchored" data-anchor-id="부록-2-신규-고전-확률과-양자-확률">부록 2: (신규) 고전 확률과 양자 확률</h2>
<p>양자역학이 혼란스러운 주된 이유 중 하나는 ’확률’의 개념이 고전과 다르기 때문입니다. 2장에서 배운 밀도 행렬을 이해하려면 이 둘의 차이를 명확히 해야 합니다.</p>
<section id="고전-확률-주사위-던지기" class="level3">
<h3 class="anchored" data-anchor-id="고전-확률-주사위-던지기">1. 고전 확률 (주사위 던지기 🎲)</h3>
<p>고전 세계의 확률은 우리의 <strong>‘무지(Ignorance)’</strong>를 나타냅니다.</p>
<ul>
<li><strong>상태:</strong> 주사위는 이미 1, 2, 3, 4, 5, 6 중 <strong>하나의 명확한 상태</strong>를 가지고 있습니다. 우리는 그저 던지기 전까지 무엇이 나올지 모를 뿐입니다.</li>
<li><strong>확률:</strong> 각 면이 나올 확률 <span class="math inline">\(p_i = 1/6\)</span> 입니다.</li>
<li><strong>기대값:</strong> 주사위를 던졌을 때 나올 값의 평균(기대값)은 각 값에 확률을 곱해 더합니다. <span class="math display">\[\langle \text{값} \rangle = \sum_i p_i \cdot (\text{값})_i = (1/6)·1 + (1/6)·2 + \dots + (1/6)·6 = 3.5\]</span></li>
</ul>
</section>
<section id="양자-확률-양자-동전" class="level3">
<h3 class="anchored" data-anchor-id="양자-확률-양자-동전">2. 양자 확률 (양자 동전 🪙)</h3>
<p>양자 세계의 확률은 본질적으로 불확정적이며, <strong>‘중첩(Superposition)’</strong>에서 비롯됩니다.</p>
<ul>
<li><strong>상태:</strong> 양자 동전(큐빗)은 <span class="math inline">\(|0\rangle\)</span>(앞) 또는 <span class="math inline">\(|1\rangle\)</span>(뒤)일 필요가 없습니다. 측정하기 전까지는 두 상태가 <strong>동시에 중첩된</strong> 상태일 수 있습니다. <span class="math display">\[|\psi\rangle = c_0 |0\rangle + c_1 |1\rangle\]</span></li>
<li><strong>확률 진폭:</strong> <span class="math inline">\(c_0, c_1\)</span>은 복소수이며 <strong>‘확률 진폭’</strong>이라 부릅니다.</li>
<li><strong>확률 (본 규칙):</strong> <span class="math inline">\(c_i\)</span> 자체가 확률이 아니라, 그 <strong>진폭의 제곱</strong>이 확률입니다. <span class="math inline">\(P(0) = |c_0|^2, \quad P(1) = |c_1|^2 \quad (\text{단, } |c_0|^2 + |c_1|^2 = 1)\)</span></li>
<li><strong>기대값:</strong> 1장에서 배운 브라-캣 표기법을 사용합니다. <span class="math inline">\(\hat{A}\)</span>의 기대값은 다음과 같습니다. <span class="math display">\[\langle \hat{A} \rangle = \langle\psi|\hat{A}|\psi\rangle\]</span></li>
</ul>
</section>
<section id="결정적-차이-무지인가-중첩인가" class="level3">
<h3 class="anchored" data-anchor-id="결정적-차이-무지인가-중첩인가">3. 결정적 차이: ’무지’인가, ’중첩’인가?</h3>
<p>2장의 <strong>밀도 행렬</strong>은 이 두 가지 다른 종류의 ’불확실성’을 수학적으로 구별하고 통합하는 도구입니다.</p>
<section id="a.-혼합-상태-고전적-무지" class="level4">
<h4 class="anchored" data-anchor-id="a.-혼합-상태-고전적-무지">A. 혼합 상태 (고전적 무지)</h4>
<p>“50% 확률로 <span class="math inline">\(|0\rangle\)</span> 상태이고, 50% 확률로 <span class="math inline">\(|1\rangle\)</span> 상태인” 앙상블(집합)이 있다고 합시다. 이는 우리가 시스템이 <span class="math inline">\(|0\rangle\)</span>인지 <span class="math inline">\(|1\rangle\)</span>인지 <strong>몰라서</strong> 발생하는 고전적 확률입니다.</p>
<ul>
<li><strong>밀도 행렬:</strong> <span class="math inline">\(\rho_{\text{mix}} = \sum_i p_i |\psi_i\rangle\langle\psi_i| = 0.5 |0\rangle\langle 0| + 0.5 |1\rangle\langle 1| = \begin{pmatrix} 0.5 &amp; 0 \\ 0 &amp; 0.5 \end{pmatrix}\)</span></li>
<li><strong>특징:</strong> 대각선에만 확률이 있고, 비대각선(간섭항)은 0입니다.</li>
<li><strong>순수도:</strong> <span class="math inline">\(\mathrm{Tr}(\rho_{\text{mix}}^2) = \mathrm{Tr}\left( \begin{pmatrix} 0.25 &amp; 0 \\ 0 &amp; 0.25 \end{pmatrix} \right) = 0.5 &lt; 1\)</span></li>
</ul>
</section>
<section id="b.-순수-상태-양자-중첩" class="level4">
<h4 class="anchored" data-anchor-id="b.-순수-상태-양자-중첩">B. 순수 상태 (양자 중첩)</h4>
<p>“<span class="math inline">\(|0\rangle\)</span>과 <span class="math inline">\(|1\rangle\)</span>이 50:50으로 <strong>중첩된</strong>” 단일 시스템이 있다고 합시다. <span class="math inline">\(|\psi\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)\)</span></p>
<ul>
<li><strong>밀도 행렬:</strong> <span class="math inline">\(\rho_{\text{pure}} = |\psi\rangle\langle\psi| = \left( \frac{1}{\sqrt{2}}\begin{pmatrix} 1 \\ 1 \end{pmatrix} \right) \left( \frac{1}{\sqrt{2}}\begin{pmatrix} 1 &amp; 1 \end{pmatrix} \right) = \begin{pmatrix} 0.5 &amp; 0.5 \\ 0.5 &amp; 0.5 \end{pmatrix}\)</span></li>
<li><strong>특징:</strong> <strong>비대각 성분</strong>(<span class="math inline">\(\rho_{01}, \rho_{10}\)</span>)이 살아있습니다. 이것이 ‘간섭’ 또는 ’결맞음’의 수학적 증거입니다.</li>
<li><strong>순수도:</strong> <span class="math inline">\(\mathrm{Tr}(\rho_{\text{pure}}^2) = \mathrm{Tr}\left( \begin{pmatrix} 0.5 &amp; 0.5 \\ 0.5 &amp; 0.5 \end{pmatrix} \begin{pmatrix} 0.5 &amp; 0.5 \\ 0.5 &amp; 0.5 \end{pmatrix} \right) = \mathrm{Tr}\left( \begin{pmatrix} 0.5 &amp; 0.5 \\ 0.5 &amp; 0.5 \end{pmatrix} \right) = 1\)</span></li>
</ul>
<p><strong>요약:</strong> <span class="math inline">\(\rho_{\text{mix}}\)</span>와 <span class="math inline">\(\rho_{\text{pure}}\)</span>는 <span class="math inline">\(\sigma_z\)</span> 측정 확률(둘 다 50%)은 같지만, <span class="math inline">\(\sigma_x\)</span> 측정 확률은 다릅니다. 이처럼 <strong>순수도(<span class="math inline">\(\mathrm{Tr}(\rho^2)\)</span>)</strong>는 시스템이 순수한 양자 중첩 상태(<span class="math inline">\(=1\)</span>)인지, 아니면 고전적인 확률이 섞인 혼합 상태(<span class="math inline">\(&lt;1\)</span>)인지를 구별하는 핵심 지표입니다.</p>
</section>
</section>
</section>
<section id="부록-3-표기법-가이드" class="level2">
<h2 class="anchored" data-anchor-id="부록-3-표기법-가이드">부록 3: 표기법 가이드</h2>
<p>이 부록은 본문 전반에 걸쳐 사용되는 수학 및 물리 표기법의 관례를 설명합니다.</p>
<section id="선형대수-표기-d_mathcalp_n" class="level3">
<h3 class="anchored" data-anchor-id="선형대수-표기-d_mathcalp_n">1. 선형대수 표기: <span class="math inline">\([D]_{\mathcal{P}_n}\)</span></h3>
<ul>
<li><strong>의미:</strong> <span class="math inline">\([D]_{\mathcal{P}_n}\)</span>에서 대괄호 <code>[ ]</code>는 “선형변환 D의 <strong>행렬 표현</strong>”을 의미합니다.</li>
<li><strong>아래 첨자:</strong> <span class="math inline">\(\mathcal{P}_n\)</span>는 그 행렬이 특정 기저(이 경우, 다항식 공간 <span class="math inline">\(\mathcal{P}_n\)</span>의 기저 <span class="math inline">\(\{1, x, \dots, x^n\}\)</span>)에 대해 표현되었음을 나타냅니다.</li>
<li><strong>구분:</strong> 이는 디랙의 브라-캣 <span class="math inline">\(\langle \psi |\)</span>나 교환자 <span class="math inline">\([A, B]\)</span>와는 다른, “행렬로 적는다”는 선형대수의 관례적 표기입니다.</li>
</ul>
</section>
<section id="대괄호-가-흔히-쓰이는-경우" class="level3">
<h3 class="anchored" data-anchor-id="대괄호-가-흔히-쓰이는-경우">2. 대괄호 <code>[ ]</code>가 흔히 쓰이는 경우</h3>
<p>대괄호는 맥락에 따라 매우 다른 의미를 가지므로 주의가 필요합니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">맥락</th>
<th style="text-align: left;">표기 예시</th>
<th style="text-align: left;">의미</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>선형사상 표현</strong></td>
<td style="text-align: left;"><span class="math inline">\([T]_{\beta}^{\gamma}\)</span></td>
<td style="text-align: left;">기저 <span class="math inline">\(\beta, \gamma\)</span>에 대한 변환 <span class="math inline">\(T\)</span>의 행렬 표현</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>행렬 및 성분</strong></td>
<td style="text-align: left;"><span class="math inline">\(A = [a_{ij}]\)</span></td>
<td style="text-align: left;">행렬 본체 또는 그 성분 <span class="math inline">\(a_{ij}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>교환자</strong></td>
<td style="text-align: left;"><span class="math inline">\([A, B]\)</span></td>
<td style="text-align: left;"><span class="math inline">\(AB - BA\)</span>. 두 연산자의 비가환성을 측정</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>리 괄호</strong></td>
<td style="text-align: left;"><span class="math inline">\([X, Y]\)</span></td>
<td style="text-align: left;">두 벡터장의 리 괄호 (미분기하)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>반대칭화</strong></td>
<td style="text-align: left;"><span class="math inline">\(T_{[ab]}\)</span></td>
<td style="text-align: left;">텐서 인덱스의 반대칭화. <span class="math inline">\(\frac{1}{2}(T_{ab} - T_{ba})\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">아이버슨 괄호</td>
<td style="text-align: left;"><span class="math inline">\([P]\)</span></td>
<td style="text-align: left;">조건 <span class="math inline">\(P\)</span>가 참이면 1, 거짓이면 0인 지시 함수</td>
</tr>
<tr class="odd">
<td style="text-align: left;">동치류</td>
<td style="text-align: left;"><span class="math inline">\([a]\)</span></td>
<td style="text-align: left;">원소 <span class="math inline">\(a\)</span>가 속한 동치류</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="부록-4-군의-분류-체계-u-s-o-그리고-그-너머" class="level2">
<h2 class="anchored" data-anchor-id="부록-4-군의-분류-체계-u-s-o-그리고-그-너머">부록 4: 군의 분류 체계: U, S, O, 그리고 그 너머</h2>
<p>3장에서 우리는 시간 이동(<span class="math inline">\(U(1)\)</span>), 회전(<span class="math inline">\(SU(2)\)</span>)과 같은 리 군을 만났습니다. 군의 종류는 무한히 많지만, 이들을 체계적으로 분류하는 여러 기준이 존재합니다. <span class="math inline">\(U, S, O\)</span>와 같은 기호는 그중 <strong>“어떤 속성을 보존하는가”</strong>에 따른 분류입니다.</p>
<p>이 부록에서는 이 분류 기준이 전체 분류 체계의 어디에 위치하는지, 그리고 물리학과 직결되는 다른 중요한 분류 기준(위상, 대수)은 무엇인지 살펴봅니다.</p>
<section id="근본적인-분류-이산-군-vs.-연속-군" class="level3">
<h3 class="anchored" data-anchor-id="근본적인-분류-이산-군-vs.-연속-군">1. 근본적인 분류: 이산 군 vs.&nbsp;연속 군</h3>
<p>가장 첫 번째 분류 기준은 군의 원소들이 <strong>‘연속적(continuous)’</strong>인지 <strong>‘이산적(discrete)’</strong>인지입니다.</p>
<ul>
<li><p><strong>이산 군 (Discrete Group)</strong>:</p>
<ul>
<li>원소들이 ‘뚝뚝’ 떨어져 있어 셀 수 있습니다. (예: 정수의 덧셈 군 <span class="math inline">\(Z\)</span>)</li>
<li>연속적인 매개변수가 없습니다.</li>
<li><strong>물리 예시</strong>: 결정 격자의 대칭(병진, 회전), <span class="math inline">\(Z_2\)</span> (패리티/반사 대칭), <span class="math inline">\(S_n\)</span> (동일 입자의 치환).</li>
</ul></li>
<li><p><strong>연속 군 (Continuous Group) / 리 군 (Lie Group)</strong>:</p>
<ul>
<li>원소들이 ‘매끄럽게’ 연결되어 연속적인 매개변수(예: 각도 <span class="math inline">\(\theta\)</span>, 시간 <span class="math inline">\(t\)</span>)로 기술됩니다.</li>
<li>그 자체로 ‘매끄러운 다양체(manifold)’ 구조를 가집니다. (미분 가능)</li>
<li><strong>물리 예시</strong>: 시간 이동, 공간 이동, 회전, 로렌츠 변환 등.</li>
<li>(이후의 분류는 주로 이 리 군에 초점을 맞춥니다.)</li>
</ul></li>
</ul>
</section>
<section id="속성property에-따른-분류-the-s-u-o-hierarchy" class="level3">
<h3 class="anchored" data-anchor-id="속성property에-따른-분류-the-s-u-o-hierarchy">2. 속성(Property)에 따른 분류 (The S, U, O Hierarchy)</h3>
<p>물리학에서 가장 유용한 분류는 “이 변환이 무엇을 보존하는가?”에 기반합니다. 이는 대부분 <strong>행렬 군(Matrix Group)</strong>으로 표현되며, 다음과 같은 제약 조건의 조합으로 정의됩니다.</p>
<section id="a.-모든-것의-시작-일반-선형-군-gln" class="level4">
<h4 class="anchored" data-anchor-id="a.-모든-것의-시작-일반-선형-군-gln">A. 모든 것의 시작: “일반 선형 군” GL(n)</h4>
<ul>
<li><p><strong>GL(n, R)</strong> 또는 <strong>GL(n, C)</strong></p>
<ul>
<li><strong>G (General)</strong>: 일반적인</li>
<li><strong>L (Linear)</strong>: 선형 (행렬)</li>
<li><strong>n</strong>: 행렬의 크기 (<span class="math inline">\(n \times n\)</span>)</li>
<li><strong>R / C</strong>: 행렬의 원소가 실수(Real)인지 복소수(Complex)인지.</li>
</ul>
<p><strong>GL(n)</strong>은 “역행렬이 존재하는 모든 <span class="math inline">\(n \times n\)</span> 행렬의 집합”입니다. 이는 “모든 선형 변환”이라는 가장 일반적인 조건을 나타냅니다. 다른 모든 리 군은 이 GL(n)의 부분 집합(subgroup)에 속하며, GL(n)에 <strong>추가적인 제약 조건</strong>을 가함으로써 정의됩니다.</p></li>
</ul>
</section>
<section id="b.-제약-조건-1-내적inner-product의-보존" class="level4">
<h4 class="anchored" data-anchor-id="b.-제약-조건-1-내적inner-product의-보존">B. 제약 조건 (1): 내적(Inner Product)의 보존</h4>
<p>물리적으로 가장 중요한 제약 조건은 “변환을 해도 기하학적 속성(길이, 각도)이 변하지 않아야 한다”는 것입니다.</p>
<ul>
<li><p><strong>U(n) - 유니터리 군 (Unitary Group)</strong></p>
<ul>
<li><strong>U (Unitary)</strong>: 유니터리</li>
<li><strong>제약 조건</strong>: <span class="math inline">\(M^\dagger M = \mathbf{1}\)</span> ( <span class="math inline">\(M^\dagger\)</span>는 에르미트 켤레)</li>
<li><strong>의미</strong>: <strong>복소(Complex) 벡터 공간</strong>의 내적(확률 진폭)을 보존합니다.</li>
<li><strong>물리학</strong>: <strong>양자역학의 모든 대칭성</strong> (<span class="math inline">\(U(1), SU(2), SU(3)\)</span> 등)의 모체입니다.</li>
</ul></li>
<li><p><strong>O(n) - 직교 군 (Orthogonal Group)</strong></p>
<ul>
<li><strong>O (Orthogonal)</strong>: 직교</li>
<li><strong>제약 조건</strong>: <span class="math inline">\(M^T M = \mathbf{1}\)</span> ( <span class="math inline">\(M^T\)</span>는 단순 전치)</li>
<li><strong>의미</strong>: <strong>실수(Real) 벡터 공간</strong>의 내적(길이, 각도)을 보존합니다.</li>
<li><strong>물리학</strong>: 고전 역학의 3D 공간 <strong>회전(<span class="math inline">\(SO(3)\)</span>)</strong> 및 <strong>반사(Reflection)</strong>.</li>
</ul></li>
</ul>
</section>
<section id="c.-제약-조건-2-부피와-방향성의-보존-행렬식" class="level4">
<h4 class="anchored" data-anchor-id="c.-제약-조건-2-부피와-방향성의-보존-행렬식">C. 제약 조건 (2): 부피와 방향성의 보존 (행렬식)</h4>
<p>두 번째 제약 조건은 “변환을 해도 부피(volume)가 변하지 않아야 한다”는 것입니다.</p>
<ul>
<li><strong>S (Prefix) - 스페셜 (Special)</strong>
<ul>
<li><strong>S (Special)</strong>: 특별한</li>
<li><strong>제약 조건</strong>: <strong><span class="math inline">\(\det(M) = 1\)</span></strong></li>
<li><strong>의미</strong>: 부피를 보존하고(<span class="math inline">\(|\det(M)|=1\)</span>), 방향성(예: 오른손 좌표계)을 뒤집지 않는(<span class="math inline">\(\det(M) &gt; 0\)</span>) 변환들의 집합입니다.</li>
</ul></li>
</ul>
</section>
<section id="d.-분류의-완성-기호의-조합" class="level4">
<h4 class="anchored" data-anchor-id="d.-분류의-완성-기호의-조합">D. 분류의 완성: 기호의 조합</h4>
<ul>
<li><strong>GL(n)</strong>: (모체) 역행렬이 있는 모든 행렬.</li>
<li><strong>SL(n)</strong>: <strong>Special</strong> Linear. (<span class="math inline">\(\det(M)=1\)</span>인 선형 변환)</li>
<li><strong>O(n)</strong>: Orthogonal. (회전 + <strong>반전</strong>).</li>
<li><strong>SO(n)</strong>: <strong>Special</strong> Orthogonal. (<span class="math inline">\(\det(M)=1\)</span>인 직교 변환. <strong>“순수 회전”</strong>만 해당).</li>
<li><strong>U(n)</strong>: Unitary. (양자 대칭 + 전역 위상 포함).</li>
<li><strong>SU(n)</strong>: <strong>Special</strong> Unitary. (<span class="math inline">\(\det(M)=1\)</span>인 유니터리 변환. 전역 위상 제외).</li>
</ul>
<hr>
</section>
</section>
<section id="위상topology에-따른-분류-물리학과-무관해-보이지만-결정적인-기준" class="level3">
<h3 class="anchored" data-anchor-id="위상topology에-따른-분류-물리학과-무관해-보이지만-결정적인-기준">3. 위상(Topology)에 따른 분류 (물리학과 무관해 보이지만 결정적인 기준)</h3>
<p>순수 수학자들은 군의 “모양”이 어떤지, 즉 위상(Topology)에 따라 군을 분류합니다. 이는 물리학과 무관해 보였으나, <strong>양자역학의 스핀(<span class="math inline">\(SU(2)\)</span> vs <span class="math inline">\(SO(3)\)</span>)</strong>과 <strong>시공간 대칭(로렌츠 군)</strong>을 이해하는 데 결정적인 역할을 했습니다.</p>
<ul>
<li><p><strong>Compact vs.&nbsp;Non-compact (공간의 유한성)</strong></p>
<ul>
<li><strong>Compact (유한한)</strong>: 군의 공간이 “닫혀있고 유한한 크기”를 갖습니다. (예: 원, 구)
<ul>
<li><strong>예</strong>: <span class="math inline">\(U(1)\)</span>, <span class="math inline">\(O(n)\)</span>, <span class="math inline">\(SO(n)\)</span>, <span class="math inline">\(U(n)\)</span>, <span class="math inline">\(SU(n)\)</span>은 <strong>모두 Compact</strong>입니다.</li>
<li><strong>물리학</strong>: Compact 군은 양자역학의 안정적인(유한 차원 유니터리) 표현을 보장합니다.</li>
</ul></li>
<li><strong>Non-compact (무한한)</strong>: 군의 공간이 “열려있거나 무한히 뻗어 나갑니다”.
<ul>
<li><strong>예</strong>: <span class="math inline">\(GL(n)\)</span>, <span class="math inline">\(SL(n)\)</span> (행렬 원소가 무한히 커질 수 있음), 그리고 특수 상대성 이론의 <strong>로렌츠 군 <span class="math inline">\(SO(1,3)\)</span></strong>.</li>
<li><strong>물리학</strong>: 로렌츠 군(boost는 무한 속도에 근접)이 Non-compact라는 사실은 시공간 대칭이 내부 대칭(<span class="math inline">\(SU(n)\)</span>)과 근본적으로 다름을 시사합니다.</li>
</ul></li>
</ul></li>
<li><p><strong>Connected vs.&nbsp;Disconnected (조각의 개수)</strong></p>
<ul>
<li><strong>Connected (연결된)</strong>: 모든 군의 원소가 항등원에서부터 ‘매끄럽게’ 이어져 있습니다. (한 조각)
<ul>
<li><strong>예</strong>: <span class="math inline">\(SO(3)\)</span> (모든 회전은 0°에서부터 연속적으로 만들 수 있음), <span class="math inline">\(SU(2)\)</span>.</li>
</ul></li>
<li><strong>Disconnected (분리된)</strong>: 군이 여러 조각으로 나뉘어 있습니다.
<ul>
<li><strong>예</strong>: <span class="math inline">\(O(3)\)</span>. <span class="math inline">\(O(3)\)</span>는 <span class="math inline">\(\det=1\)</span>인 “회전” 조각(<span class="math inline">\(SO(3)\)</span>)과 <span class="math inline">\(\det=-1\)</span>인 “반전” 조각으로 나뉩니다. 두 조각은 연속적으로 연결될 수 없습니다.</li>
</ul></li>
</ul></li>
<li><p><strong>Simply Connected vs.&nbsp;Multiply Connected (공간의 “구멍”)</strong></p>
<ul>
<li><strong>Simply Connected (단순 연결)</strong>: 공간 내부의 모든 닫힌 고리(loop)가 하나의 점으로 수축될 수 있습니다. (구멍 없음. 예: 구 <span class="math inline">\(S^2\)</span>)
<ul>
<li><strong>예</strong>: <strong><span class="math inline">\(SU(2)\)</span></strong></li>
</ul></li>
<li><strong>Multiply Connected (다중 연결)</strong>: 점으로 수축될 수 없는 “구멍”이 있습니다. (예: 도넛 <span class="math inline">\(T^2\)</span>)
<ul>
<li><strong>예</strong>: <strong><span class="math inline">\(SO(3)\)</span></strong></li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>💡 심층 탐구: <span class="math inline">\(SU(2)\)</span>와 <span class="math inline">\(SO(3)\)</span> - 스핀(Spin)의 수학적 기원</strong></p>
</blockquote>
<blockquote class="blockquote">
<p><span class="math inline">\(SU(2)\)</span>와 <span class="math inline">\(SO(3)\)</span>는 생성자 레벨(리 대수)에서는 동일하지만, 군(Group) 레벨에서는 다릅니다. <span class="math inline">\(SO(3)\)</span>는 “구멍”이 있습니다. <span class="math inline">\(SO(3)\)</span>에서 360° 회전은 항등원(원점)으로 돌아오는 닫힌 고리이지만, 이 고리는 수축 불가능합니다. (반면 720° 회전은 수축 가능합니다.)</p>
</blockquote>
<blockquote class="blockquote">
<p><span class="math inline">\(SU(2)\)</span>는 <span class="math inline">\(SO(3)\)</span>의 이 “구멍”을 메운 <strong>“더블 커버(Double Cover)”</strong> 버전입니다. <span class="math inline">\(SU(2)\)</span>에서는 360° 회전이 항등원(<span class="math inline">\(\mathbf{1}\)</span>)이 아닌 <span class="math inline">\(-\mathbf{1}\)</span>로 갑니다. 720°를 회전해야 비로소 항등원으로 돌아옵니다.</p>
</blockquote>
<blockquote class="blockquote">
<p>이것이 바로 <strong>스핀 1/2 입자(전자)</strong>가 360° 회전하면 파동 함수가 <span class="math inline">\(-\psi\)</span>가 되고, 720° 회전해야 <span class="math inline">\(+\psi\)</span>가 되는 기묘한 현상의 <strong>수학적 정체</strong>입니다. 물리학이 <span class="math inline">\(SO(3)\)</span>(고전 회전)뿐만 아니라 <span class="math inline">\(SU(2)\)</span>(양자 스핀)를 필요로 하는 이유는, 자연의 회전 대칭이 <span class="math inline">\(SU(2)\)</span>라는 (위상적으로 더 완벽한) 구조를 따르기 때문입니다.</p>
</blockquote></li>
</ul>
<hr>
</section>
<section id="대수algebra에-따른-분류-단순성" class="level3">
<h3 class="anchored" data-anchor-id="대수algebra에-따른-분류-단순성">4. 대수(Algebra)에 따른 분류 (단순성)</h3>
<p>마지막으로 군의 생성자(리 대수)가 갖는 대수적 구조로 분류합니다.</p>
<ul>
<li><p><strong>Abelian vs.&nbsp;Non-Abelian (교환성)</strong></p>
<ul>
<li><strong>Abelian (가환)</strong>: <span class="math inline">\([G_i, G_j] = 0\)</span>. (예: <span class="math inline">\(U(1)\)</span>, 시간/공간 이동)</li>
<li><strong>Non-Abelian (비가환)</strong>: <span class="math inline">\([G_i, G_j] \neq 0\)</span>. (예: <span class="math inline">\(SU(n)\)</span>, <span class="math inline">\(SO(n)\)</span>, 회전)</li>
</ul></li>
<li><p><strong>Simple vs.&nbsp;Semi-simple (분해성)</strong></p>
<ul>
<li><strong>Simple (단순)</strong>: 더 이상 분해할 수 없는 근본적인 대칭의 “빌딩 블록”입니다. (예: <span class="math inline">\(SU(n)\)</span>, <span class="math inline">\(SO(n)\)</span> 등)</li>
<li><strong>Semi-simple (반단순)</strong>: Simple 군들의 직접 곱(direct product)으로 분해됩니다. (예: <span class="math inline">\(SU(2) \times SU(3)\)</span>)</li>
<li><strong>그 외 (Abelian 등)</strong>: <span class="math inline">\(U(1)\)</span>은 Simple이 아닙니다.</li>
</ul>
<blockquote class="blockquote">
<p><strong>💡 물리학적 연결 (표준 모형)</strong></p>
</blockquote>
<blockquote class="blockquote">
<p>현대 입자물리학의 <strong>표준 모형(Standard Model)</strong>은 <span class="math inline">\(U(1) \times SU(2) \times SU(3)\)</span>라는 게이지 군을 기반으로 합니다. 이 분류 체계에 따르면, 표준 모형은 <strong>“하나의 Abelian 군(<span class="math inline">\(U(1)\)</span>)과 두 개의 Simple Non-Abelian 군(<span class="math inline">\(SU(2), SU(3)\)</span>)의 곱으로 이루어진 리 군”</strong>으로 완벽하게 기술됩니다.</p>
</blockquote></li>
</ul>
</section>
</section>
<section id="부록-5-핵심-학습-로드맵-및-전략" class="level2">
<h2 class="anchored" data-anchor-id="부록-5-핵심-학습-로드맵-및-전략">부록 5: 핵심 학습 로드맵 및 전략</h2>
<p>이 부록은 본문의 12개 챕터를 어떤 순서와 전략으로 학습하면 좋은지 개괄적인 지도를 제공합니다.</p>
<section id="단계-핵심-로드맵" class="level3">
<h3 class="anchored" data-anchor-id="단계-핵심-로드맵">1. 4단계 핵심 로드맵</h3>
<p>학습 순서는 수학적 기초에서 시작하여 양자 공리, 개방계(결맞음), 그리고 현대 양자 기초론으로 심화됩니다.</p>
<ol type="1">
<li><strong>수학적 기초 (1부)</strong>
<ul>
<li>힐베르트 공간 (내적, 완비성)</li>
<li>디랙 표기 (브라-캣)</li>
<li>선형 연산자 (헤르미트, 유니터리, 프로젝터)</li>
<li>텐서곱, 밀도행렬, 부분자취</li>
</ul></li>
<li><strong>동역학 및 경로 (2부)</strong>
<ul>
<li>변분법 및 라그랑주 역학 (정지작용 원리)</li>
<li>경로적분 (범함수 적분, 정상위상 근사)</li>
</ul></li>
<li><strong>정보와 결맞음 (3부)</strong>
<ul>
<li>개방계 및 양자채널 (CPTP 맵, 크라우스 표현)</li>
<li>일관성 역사 (디코히어런스 함수, 확률 조건)</li>
<li>지연선택, 양자 다윈주의 (객관성)</li>
</ul></li>
<li><strong>시간과 실재성 (4부)</strong>
<ul>
<li>시간의 등장 (Page-Wootters, 열적 시간)</li>
<li>인과 구조 (불확정 인과순서)</li>
<li>실재성 (레게트-가르그 부등식)</li>
</ul></li>
</ol>
</section>
<section id="권장-학습-전략" class="level3">
<h3 class="anchored" data-anchor-id="권장-학습-전략">2. 권장 학습 전략 💡</h3>
<p>본문의 내용은 표준 학부 과정을 넘어서는 <strong>대학원 수준의 고급 주제</strong>를 포함합니다. 따라서 다음과 같은 3단계 접근이 효율적입니다.</p>
<ul>
<li><p><strong>1단계 (개념 수용):</strong> 힐베르트 공간, 밀도행렬, 부분자취, CPTP 등 핵심 용어, 표기, 기본 성질을 먼저 받아들이고 암기합니다.</p></li>
<li><p><strong>2단계 (예제 적용):</strong> 큐빗(2x2 행렬)이나 간단한 가우시안 예제 등 계산 가능한 모델에 적용하여 “작동 방식”과 수학적 감각을 익힙니다.</p></li>
<li><p><strong>3단계 (증명 심화):</strong> 계산이 익숙해진 후, 개념의 일반적인 성질이 궁금해질 때 관련 정리의 증명과 이론적 배경을 학습합니다.</p></li>
</ul>
</section>
<section id="확장성-양자-우주론" class="level3">
<h3 class="anchored" data-anchor-id="확장성-양자-우주론">3. 확장성: 양자 우주론 🌌</h3>
<p>만약 이 책의 내용을 바탕으로 <strong>양자 우주론(Quantum Cosmology)</strong>으로 확장하고자 한다면, 다음 3가지 핵심 블록을 추가로 학습해야 합니다.</p>
<ol type="1">
<li><strong>미분기하 및 일반상대론 (GR)</strong></li>
<li><strong>곡률 시공간의 양자장론 (QFT in Curved Spacetime)</strong></li>
<li><strong>고급 연산자대수</strong> (본문의 C* 대수 심화)</li>
</ol>
<p>본문에서 다룬 ’일관성 역사’와 ’열적 시간 가설’은 이 상위 주제로 나아가는 중요한 개념적 다리 역할을 할 것입니다.</p>
</section>
</section>
<section id="부록-6-이-책의-위상과-다음-단계" class="level2">
<h2 class="anchored" data-anchor-id="부록-6-이-책의-위상과-다음-단계">부록 6: 이 책의 위상과 다음 단계</h2>
<p>이 책 “양자역사 수학”은 표준적인 양자역학 교과서가 아닙니다. 이 책은 1부에서 양자론의 핵심 수학(힐베르트 공간, 밀도 행렬)을 다진 후, 곧바로 ‘시간’, ‘역사’, ‘실재성’, ’객관성’이라는 현대 양자 기초론의 가장 심오한 질문들로 돌입합니다.</p>
<p>이 책의 위상은 <strong>표준 양자역학</strong>과 <strong>현대 연구 주제(양자 정보, 양자 우주론)</strong> 사이의 핵심적인 <strong>개념적/수학적 징검다리</strong>입니다.</p>
<section id="학문-영역별-커버리지" class="level3">
<h3 class="anchored" data-anchor-id="학문-영역별-커버리지">1. 학문 영역별 커버리지</h3>
<p>이 책을 마친 독자는 각 학문 분야의 핵심 기반을 갖추게 됩니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">학문 영역</th>
<th style="text-align: left;">본서가 커버하는 핵심 영역 (다시 학습할 필요 없는 부분)</th>
<th style="text-align: left;">추가 학습이 필요한 영역 (다음 단계)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>표준 양자역학</strong></td>
<td style="text-align: left;"><strong>수학적 공리계 전체:</strong> 힐베르트 공간, 연산자, 텐서곱, 밀도 행렬(1, 2장). <strong>고급 동역학:</strong> 라그랑주 및 경로적분(3, 4장).</td>
<td style="text-align: left;">특정 해밀토니안 풀이(예: 수소 원자), 각운동량 합성, 정교한 섭동 이론(Perturbation Theory) 등.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>양자 정보/컴퓨터 (QIT/QC)</strong></td>
<td style="text-align: left;"><strong>QIT의 “이유(Why)”:</strong> 큐빗, 얽힘, 혼합 상태의 수학(1, 2장). <strong>잡음과 오류의 원리:</strong> CPTP 맵, 크라우스 연산자(5장). <strong>측정과 정보:</strong> 결맞음, 지연선택, 양자 지우개(6, 7장).</td>
<td style="text-align: left;"><strong>QIT/QC의 “방법(How)”:</strong> 구체적인 양자 알고리즘(쇼어, 그로버), 양자 오류 정정 코드(QECC), 특정 하드웨어 구현 방식.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>양자 우주론 (Quantum Cosmology)</strong></td>
<td style="text-align: left;"><strong>핵심 난제의 수학적 접근:</strong><br>1. <strong>고전성 출현:</strong> 일관성 역사(6장), 양자 다윈주의(8장).<br>2. <strong>시간의 문제:</strong> 창발적 시간(9장), 열적 시간(10장).</td>
<td style="text-align: left;"><strong>물리학적 배경:</strong> <strong>일반 상대성 이론(GR)</strong>. <br>휠러-드윗 방정식, 루프 양자 중력(LQG), 끈 이론(String Theory) 등의 구체적인 우주론 모델.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>모든 것의 이론 (ToE) / QFT</strong></td>
<td style="text-align: left;"><strong>고급 수학적 초석:</strong> 경로적분(4장), C* 및 폰 노이만 대수(10장).</td>
<td style="text-align: left;"><strong>양자장론(QFT)</strong>, 표준 모형(Standard Model), 일반 상대성 이론(GR), 및 이 둘을 통합하려는 시도(끈 이론, LQG 등).</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="양자-우주론으로-나아가기" class="level3">
<h3 class="anchored" data-anchor-id="양자-우주론으로-나아가기">2. 양자 우주론으로 나아가기</h3>
<p>이 책은 양자 우주론의 핵심 질문인 <strong>“시간은 무엇인가?”</strong>와 <strong>“고전 세계는 어떻게 나타나는가?”</strong>에 대한 현대적 답변(9, 10장 및 6, 8장)을 이미 상세히 다루었습니다.</p>
<p>이 책을 마친 독자가 양자 우주론이나 모든 것의 이론으로 나아가기 위해 <strong>반드시 보충해야 할 다음 영역</strong>은 명확합니다.</p>
<ol type="1">
<li><p><strong>일반 상대성 이론 (General Relativity, GR)</strong></p>
<ul>
<li><strong>이유:</strong> 우주론은 ’중력’의 이론이며, GR은 중력(시공간의 기하학)을 다루는 고전 이론입니다. 양자 우주론은 이 GR을 양자화하려는 시도입니다.</li>
<li><strong>필수 개념:</strong> 미분기하, 아인슈타인 장 방정식, 시공간 동역학.</li>
</ul></li>
<li><p><strong>양자장론 (Quantum Field Theory, QFT)</strong></p>
<ul>
<li><strong>이유:</strong> ’모든 것의 이론’은 입자를 ’장(Field)’의 들뜸으로 보는 QFT를 기본 언어로 사용합니다.</li>
<li><strong>필수 개념:</strong> 장의 양자화, 파인만 다이어그램, 재규격화(Renormalization).</li>
</ul></li>
</ol>
<p>이 책은 양자론의 <strong>철학적, 수학적 토대</strong>를 완성합니다. <strong>GR(중력/시공간)</strong>과 <strong>QFT(물질/장)</strong>라는 두 기둥을 더하면, 현대 물리학의 최전선으로 나아갈 준비를 마치게 됩니다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>