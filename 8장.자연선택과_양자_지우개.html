<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>8장. 지연선택과 양자 지우개: 나중의 선택이 현재의 통계를 결정하는 법 – 양자 시간과 역사</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./9장.양자다원주의_객관적_실재는_어떻게_탄생하는가.html" rel="next">
<link href="./7장.일관성_역사와_양자적_확률.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-731369fcf3e097af5bb2296c8ce903d3.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./8장.자연선택과_양자_지우개.html"><span class="chapter-title">8.양자 지우개</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">양자 시간과 역사</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">들어가는 말</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1장.힐베르트공간과_내적_연산자이론.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">1.힐베르트 공간과 연산자</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2장.양자_시스템의_결합과_상태.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">2.양자 시스템의 결합</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3장.대칭_군_그리고_생성자.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">3.대칭과 군</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./4장.작용_함수적과_변분_오일러-라그랑주_방정식.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">4.작용 함수와 변분법</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./5장.경로적분_공리화_범함수_적분_기호.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">5.경로적분 공리화</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./6장.열린_양자시스템의_동역학.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">6.열린 양자시스템</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./7장.일관성_역사와_양자적_확률.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">7.일관성 역사</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./8장.자연선택과_양자_지우개.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">8.양자 지우개</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./9장.양자다원주의_객관적_실재는_어떻게_탄생하는가.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">9.양자다원주의</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10장.창발적_시간-정지된_우주_속_시간의_흐름_Page-Wootters.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">10.창발적 시간</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11장.C-von_Neumann_연산자대수_열적_시간.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">11.연산자대수와 열적 시간</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12장.불확정_인과_순서.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">12.불확정 인과 순서</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13장.레게트-가르그_부등식-시간_속_숨겨진_양자성.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">13.레게트-가르그 부등식</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14.부록.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">부록</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#기본-개념-fundamental-concepts" id="toc-기본-개념-fundamental-concepts" class="nav-link active" data-scroll-target="#기본-개념-fundamental-concepts">1. 기본 개념 (Fundamental Concepts)</a></li>
  <li><a href="#기호-및-핵심-관계식" id="toc-기호-및-핵심-관계식" class="nav-link" data-scroll-target="#기호-및-핵심-관계식">2. 기호 및 핵심 관계식</a></li>
  <li><a href="#손쉬운-예제-examples-with-deeper-insight" id="toc-손쉬운-예제-examples-with-deeper-insight" class="nav-link" data-scroll-target="#손쉬운-예제-examples-with-deeper-insight">3. 손쉬운 예제 (Examples with Deeper Insight)</a></li>
  <li><a href="#연습문제" id="toc-연습문제" class="nav-link" data-scroll-target="#연습문제">4. 연습문제</a></li>
  <li><a href="#해설" id="toc-해설" class="nav-link" data-scroll-target="#해설">5. 해설</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">8장. 지연선택과 양자 지우개: 나중의 선택이 현재의 통계를 결정하는 법</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>양자역학의 핵심 원리 중 하나인 <strong>상보성(Complementarity)</strong>은, 우리가 어떤 시스템의 <strong>입자적 성질</strong>(예: 어느 경로를 지났는가?)과 <strong>파동적 성질</strong>(예: 경로 간 간섭 무늬)을 동시에 완벽하게 알 수 없다고 말합니다. <strong>지연선택</strong>과 <strong>양자 지우개</strong> 실험은 이 원리를 극적으로 보여주는 사고 실험이자 실제 실험입니다. 이 실험들은 우리가 ’파동이냐 입자냐’를 결정하는 측정을, 대상(예: 광자)이 이미 ’선택’을 완료했을 것이라 생각되는 시점보다 <strong>훨씬 나중에</strong> 수행해도, 그 결과가 마치 우리가 처음부터 그 설정을 한 것처럼 나타난다는 것을 보여줍니다.</p>
<section id="기본-개념-fundamental-concepts" class="level3">
<h3 class="anchored" data-anchor-id="기본-개념-fundamental-concepts">1. 기본 개념 (Fundamental Concepts)</h3>
<ul>
<li><p><strong>휠러의 지연선택 (Wheeler’s Delayed Choice)</strong>: 광자가 간섭계(예: 마하-젠더)에 이미 들어간 <em>이후에</em>, 우리가 간섭 무늬를 볼 것인지(파동 성질) 아니면 경로를 확인할 것인지(입자 성질)를 결정하는 실험입니다.</p>
<blockquote class="blockquote">
<p><strong>상세 설명: 갈림길에 선 여행자의 비유 ✈️</strong></p>
<p>한 여행자(광자)가 공항(BS1)에서 출발해 두 항로(Path 1, Path 2) 중 하나로 가는 비행기를 탔다고 상상해 봅시다.</p>
<ol type="1">
<li><strong>경로 측정 (입자)</strong>: 우리가 도착 공항을 두 개(D1, D2)로 분리해두면, 여행자는 D1 아니면 D2에 도착합니다. 우리는 “아, A 항로(Path 1)로 왔구나” 또는 “B 항로(Path 2)로 왔구나”를 100% 알 수 있습니다.</li>
<li><strong>간섭 측정 (파동)</strong>: 우리가 도착 직전, 두 항로를 하나의 ‘합류 터미널’(BS2)로 모이게 만들면, 두 경로에서 온 여행자는 서로 간섭합니다. 날씨(위상차)에 따라 모든 여행자가 D1으로만 가거나 D2로만 갈 수 있습니다 (간섭 무늬).</li>
</ol>
<p><strong>지연선택의 핵심</strong>: 이 ’합류 터미널(BS2)’을 설치할지 말지를, 여행자가 이미 비행 중일 때(BS1을 지난 후) 결정해도 결과는 똑같다는 것입니다. 우리가 터미널을 설치하면(나중 선택) 간섭 무늬가, 제거하면(나중 선택) 경로 통계가 나옵니다. 이는 광자가 미리 “나는 입자야” 또는 “나는 파동이야”라고 정하지 않았음을 시사합니다.</p>
</blockquote></li>
<li><p><strong>양자 지우개 (Quantum Eraser)</strong>: 입자의 경로를 알 수 있도록 <strong>‘표식(marker)’</strong>을 붙여 간섭 무늬를 의도적으로 없앤 다음, 나중에 그 표식 정보를 <strong>‘지우는’</strong> 측정을 통해 간섭 무늬를 <strong>선택적으로 복원</strong>하는 기법입니다.</p>
<blockquote class="blockquote">
<p><strong>상세 설명: 이중 슬릿과 편광 안경 🕶️</strong></p>
<ol type="1">
<li><strong>간섭 소거</strong>: 이중 슬릿 실험에서, 슬릿 1에는 수직 편광판(<span class="math inline">\(|V\rangle\)</span>)을, 슬릿 2에는 수평 편광판(<span class="math inline">\(|H\rangle\)</span>)을 놓습니다. 이제 어떤 광자가 스크린에 도달했는지 편광만 봐도 ’어느 슬릿’을 지났는지 100% 알 수 있습니다(<span class="math inline">\(|V\rangle \perp |H\rangle\)</span>). 이처럼 경로 정보(입자 성질)가 완벽해지면, 상보성 원리에 의해 간섭 무늬(파동 성질)는 완전히 사라집니다.</li>
<li><strong>정보 지우기</strong>: 스크린 앞에 45도 편광판(<span class="math inline">\(|D\rangle\)</span>)을 놓습니다. 이 편광판을 통과한 광자는 <span class="math inline">\(|V\rangle\)</span>에서 왔든 <span class="math inline">\(|H\rangle\)</span>에서 왔든 모두 45도 편광 상태가 됩니다. 즉, 원래의 경로 정보(<span class="math inline">\(|V\rangle\)</span>인지 <span class="math inline">\(|H\rangle\)</span>인지)가 지워졌습니다.</li>
<li><strong>간섭 복원</strong>: 놀랍게도, 45도 편광판을 <em>통과한 광자들만</em> 모아서 보면, 이들의 스크린 상 분포는 다시 간섭 무늬를 보입니다! 45도 편광판을 통과하지 못한(135도 편광판을 통과한) 광자들은 또 다른 간섭 무늬(위상이 반대인)를 보입니다.</li>
</ol>
</blockquote></li>
<li><p><strong>상보성과 정보 (Complementarity and Information)</strong>: 간섭 무늬의 선명도(가시도, <span class="math inline">\(V\)</span>)와 우리가 경로를 얼마나 잘 구별할 수 있는지(구별도, <span class="math inline">\(D\)</span>) 사이에는 <span class="math inline">\(V^2 + D^2 \le 1\)</span> 이라는 상보적 관계가 성립합니다. 양자 지우개는 <span class="math inline">\(D=1, V=0\)</span> 상태에서, ‘지우개’ 측정을 통해 <span class="math inline">\(D &lt; 1\)</span>인 부분집합을 골라내어 <span class="math inline">\(V &gt; 0\)</span>임을 보여주는 것입니다.</p></li>
</ul>
<hr>
</section>
<section id="기호-및-핵심-관계식" class="level3">
<h3 class="anchored" data-anchor-id="기호-및-핵심-관계식">2. 기호 및 핵심 관계식</h3>
<ul>
<li><p><strong>간섭 진폭 (Interference Amplitude)</strong>: 두 경로 <span class="math inline">\(\psi_1, \psi_2\)</span>를 지나는 시스템의 진폭은 <span class="math inline">\(\mathcal{A} = \psi_1 + \psi_2\)</span> 입니다. 검출 확률(강도)은 <span class="math inline">\(I \propto |\psi_1 + \psi_2|^2 = |\psi_1|^2 + |\psi_2|^2 + 2\text{Re}(\psi_1^* \psi_2)\)</span> 입니다.</p></li>
<li><p><strong>경로 표식 (Which-Path Marking)</strong>: 경로 정보를 표식(marker) 상태 <span class="math inline">\(|m_p\rangle\)</span>에 저장하면, 전체 상태는 얽힘 상태가 됩니다. <span class="math inline">\(|\Psi\rangle = \psi_1(x) |m_1\rangle + \psi_2(x) |m_2\rangle\)</span> 이때 스크린 <span class="math inline">\(x\)</span>에서 표식을 무시하고 검출할 확률(강도)은 <span class="math inline">\(I(x) \propto |\psi_1(x)|^2 + |\psi_2(x)|^2 + 2\text{Re}(\langle m_1|m_2\rangle \psi_1^*(x)\psi_2(x))\)</span></p>
<ul>
<li><span class="math inline">\(\mu = \langle m_1|m_2\rangle\)</span>는 표식 상태의 내적(overlap)입니다.</li>
<li>만약 표식이 완벽히 구별되면(<span class="math inline">\(|m_1\rangle \perp |m_2\rangle\)</span>), <span class="math inline">\(\mu = 0\)</span> 이 되어 간섭항(<span class="math inline">\(2\text{Re}(\dots)\)</span>)이 사라집니다.</li>
</ul></li>
<li><p><strong>양자 지우개 (Conditional Erasure)</strong>: 표식 상태를 ‘지우개 기저’ <span class="math inline">\(|e\rangle\)</span>로 측정(투영)할 때, <span class="math inline">\(x\)</span>에서 발견될 조건부 확률은 다음과 같습니다. <span class="math inline">\(P(x | e) = |\langle x| \langle e | \Psi \rangle|^2 = |\psi_1(x)\langle e|m_1\rangle + \psi_2(x)\langle e|m_2\rangle|^2\)</span></p>
<ul>
<li>만약 지우개 상태 <span class="math inline">\(|e\rangle\)</span>가 <span class="math inline">\(\langle e|m_1\rangle = \langle e|m_2\rangle \neq 0\)</span> 을 만족하도록(예: <span class="math inline">\(|e\rangle = \frac{1}{\sqrt{2}}(|m_1\rangle + |m_2\rangle)\)</span>) 선택되면, 간섭항이 <span class="math inline">\(\psi_1^*\psi_2\)</span> 형태로 완벽하게 복원됩니다.</li>
</ul></li>
<li><p><strong>인과성에 대한 오해 바로잡기 (No Retrocausality)</strong>:</p>
<blockquote class="blockquote">
<p><strong>💡 나중의 선택이 과거를 바꾸는가? (아니다!)</strong></p>
<p>지연선택이나 양자 지우개가 “미래의 측정이 과거의 사건(광자가 입자였는지 파동이었는지)을 바꾼다”고 오해하기 쉽습니다. 이는 사실이 아닙니다.</p>
<ul>
<li><strong>전체 통계는 불변</strong>: ’지우개’를 쓰든 안 쓰든, 스크린에 쌓인 <em>전체</em> 광자들의 분포는 항상 간섭 무늬가 없는 상태(경로 정보가 있는 상태)입니다.</li>
<li><strong>조건부 선택</strong>: ‘지우개’ 측정은 이미 스크린에 도달한 광자들 중, 특정 조건(예: 45도 편광판 통과)을 만족하는 데이터만 <em>골라내는(post-selection)</em> 작업입니다.</li>
</ul>
<p>즉, 나중의 선택은 과거의 물리적 실재를 바꾸는 것이 아니라, 우리가 <em>어떤 통계적 부분집합을 들여다볼지</em>를 결정하는 것입니다. 마치 암호문(전체 통계)을 받았는데, 나중에 받은 해독 키(지우개 측정)로 그 안의 숨겨진 메시지(간섭 무늬)를 읽어내는 것과 같습니다.</p>
</blockquote></li>
</ul>
<hr>
</section>
<section id="손쉬운-예제-examples-with-deeper-insight" class="level3">
<h3 class="anchored" data-anchor-id="손쉬운-예제-examples-with-deeper-insight">3. 손쉬운 예제 (Examples with Deeper Insight)</h3>
<ul>
<li><strong>예제 A1: 마하-젠더 간섭계</strong>
<ul>
<li><strong>BS2 제거 (입자 경로)</strong>: 첫 번째 빔 스플리터(BS1)를 지난 광자는 경로 1 또는 2를 확정적으로 따릅니다. 경로 1은 검출기 D1로, 경로 2는 검출기 D2로 갑니다. <span class="math inline">\(\Delta\phi\)</span>를 바꿔도 D1, D2의 확률은 50:50으로 일정합니다. <span class="math inline">\(\to\)</span> <strong>경로 판정 (Which-Path)</strong>.</li>
<li><strong>BS2 삽입 (파동 간섭)</strong>: 두 번째 빔 스플리터(BS2)는 두 경로를 다시 결합시킵니다. 두 경로의 위상차 <span class="math inline">\(\Delta\phi\)</span>에 따라 D1에서는 <span class="math inline">\(I \propto \cos^2(\Delta\phi/2)\)</span> (보강/소멸 간섭), D2에서는 <span class="math inline">\(I \propto \sin^2(\Delta\phi/2)\)</span>의 간섭 무늬가 나타납니다. <span class="math inline">\(\to\)</span> <strong>간섭 (Wave-like)</strong>.</li>
</ul></li>
<li><strong>예제 A2: 이중 슬릿과 편광 표식</strong>
<ul>
<li><strong>표식 (간섭 소거)</strong>: 슬릿 1 <span class="math inline">\(\to |H\rangle\)</span> 편광, 슬릿 2 <span class="math inline">\(\to |V\rangle\)</span> 편광. <span class="math inline">\(\langle H|V\rangle = 0\)</span> 이므로 간섭이 사라집니다. 스크린에는 두 개의 단일 슬릿 무늬가 겹쳐 보입니다.</li>
<li><strong>지우개 (간섭 복원)</strong>: 스크린 앞에서 45도(<span class="math inline">\(|D\rangle\)</span>) 편광판으로 측정합니다.
<ul>
<li>조건부 확률 <span class="math inline">\(P(x|D) \propto |\psi_1(x)\langle D|H\rangle + \psi_2(x)\langle D|V\rangle|^2 = |\frac{1}{\sqrt{2}}\psi_1(x) + \frac{1}{\sqrt{2}}\psi_2(x)|^2\)</span>. <span class="math inline">\(\psi_1\)</span>과 <span class="math inline">\(\psi_2\)</span>의 간섭 무늬가 복원됩니다.</li>
<li>만약 135도(<span class="math inline">\(|A\rangle\)</span>) 편광판으로 측정하면 <span class="math inline">\(P(x|A) \propto |\frac{1}{\sqrt{2}}\psi_1(x) - \frac{1}{\sqrt{2}}\psi_2(x)|^2\)</span>. 위상이 반대인 간섭 무늬가 복원됩니다.</li>
</ul></li>
</ul></li>
<li><strong>예제 B1: 얽힘을 이용한 지연선택 양자 지우개</strong>
<ul>
<li><strong>설정</strong>: 얽힌 광자 쌍(Signal, Idler)을 생성합니다.</li>
<li><strong>신호(Signal)</strong>: 이중 슬릿을 통과하여 스크린(D0)에 기록됩니다. (간섭 무늬 생성 시도)</li>
<li><strong>표식(Idler)</strong>: 신호 광자가 어느 슬릿을 지났는지에 따라 Idler 광자의 경로가 달라지도록(즉, Idler가 ’경로 정보’를 갖도록) 설정합니다.</li>
<li><strong>지연선택</strong>: 신호 광자가 D0에 <em>도달한 후에</em>, 우리는 Idler 광자의 측정 방식을 결정합니다.
<ol type="1">
<li><strong>경로 읽기</strong>: Idler가 어느 경로로 왔는지 측정합니다 (D1 또는 D2).</li>
<li><strong>경로 지우기</strong>: Idler의 두 경로를 빔 스플리터(BS)로 합친 후 측정합니다 (D3 또는 D4).</li>
</ol></li>
<li><strong>결과</strong>: D0에 기록된 전체 데이터는 간섭 무늬가 없습니다. 하지만 이 데이터를 ‘Idler가 D3에서 검출됨’ 조건으로 골라내면 간섭 무늬가 나타나고, ‘Idler가 D1에서 검출됨’ 조건으로 골라내면 간섭 무늬가 없습니다.</li>
</ul></li>
</ul>
<hr>
</section>
<section id="연습문제" class="level3">
<h3 class="anchored" data-anchor-id="연습문제">4. 연습문제</h3>
<ol type="1">
<li><strong>가시도와 표식 내적</strong>: 두 경로(<span class="math inline">\(\psi_1, \psi_2\)</span>)가 표식 상태(<span class="math inline">\(|m_1\rangle, |m_2\rangle\)</span>)와 얽혀 있을 때, 스크린 <span class="math inline">\(x\)</span>에서의 전체 강도 <span class="math inline">\(I(x)\)</span>가 표식 내적 <span class="math inline">\(\mu = \langle m_1|m_2\rangle\)</span>에 의해 <span class="math inline">\(I(x) \propto |\psi_1(x)|^2 + |\psi_2(x)|^2 + 2\text{Re}(\mu \psi_1^*(x)\psi_2(x))\)</span> 꼴이 됨을 보이십시오. <span class="math inline">\(\mu=0\)</span>일 때 간섭이 소거되는 이유는 무엇입니까?</li>
<li><strong>조건부 간섭 복원</strong>: 양자 지우개에서 표식 분석기 상태 <span class="math inline">\(|e\rangle\)</span>로 조건화했을 때, 조건부 강도 <span class="math inline">\(I(x|e)\)</span>에 간섭항이 복원되려면 <span class="math inline">\(\langle e|m_1\rangle\)</span>과 <span class="math inline">\(\langle e|m_2\rangle\)</span>가 어떤 조건을 만족해야 하는지 설명하십시오.</li>
<li><strong>마하-젠더 전이 진폭</strong>: 50:50 빔 스플리터와 거울의 전이 행렬을 이용하여, 마지막 빔 스플리터(BS2)가 있을 때와 없을 때 각각 두 검출기에서 검출될 확률을 위상차 <span class="math inline">\(\Delta\phi\)</span>의 함수로 계산하십시오.</li>
<li><strong>지연선택과 인과성</strong>: “나중의 결정”이 과거를 바꾸지 않는다는 것을, 조건부 통계와 전체 결합 분포의 불변성 관점에서 논리적으로 설명하십시오.</li>
<li><strong>상보성 관계</strong>: 보어의 상보성 원리(측정 장치의 배치가 파동 또는 입자 현상 중 하나를 배타적으로 드러낸다)가 지연선택 및 양자 지우개 실험 결과와 어떻게 양립하는지 요약하여 서술하십시오.</li>
</ol>
<hr>
</section>
<section id="해설" class="level3">
<h3 class="anchored" data-anchor-id="해설">5. 해설</h3>
<ol type="1">
<li>전체 상태는 <span class="math inline">\(|\Psi\rangle = \psi_1(x)|m_1\rangle + \psi_2(x)|m_2\rangle\)</span>입니다. 스크린 <span class="math inline">\(x\)</span>에서의 확률 밀도는 표식 상태에 대해 부분 자취를 취한 밀도 행렬 <span class="math inline">\(\rho_S(x) = \text{Tr}_m(|\Psi\rangle\langle\Psi|)\)</span>의 대각 성분입니다. <span class="math inline">\(\rho_S(x) = |\psi_1(x)|^2 |m_1\rangle\langle m_1| + |\psi_2(x)|^2 |m_2\rangle\langle m_2| + \psi_1(x)\psi_2^*(x) |m_1\rangle\langle m_2| + \dots\)</span> <span class="math inline">\(I(x) = \langle x|\text{Tr}_m(\rho_S(x))|x\rangle\)</span> … (이 유도는 복잡함). 더 쉬운 방법: <span class="math inline">\(I(x) = \text{Tr}(\hat{P}_x |\Psi\rangle\langle\Psi|) = \langle\Psi|\hat{P}_x|\Psi\rangle = ( \psi_1^*\langle m_1| + \psi_2^*\langle m_2| ) (\psi_1|m_1\rangle + \psi_2|m_2\rangle) = |\psi_1|^2\langle m_1|m_1\rangle + |\psi_2|^2\langle m_2|m_2\rangle + \psi_1^*\psi_2 \langle m_1|m_2\rangle + \psi_2^*\psi_1 \langle m_2|m_1\rangle\)</span>. <span class="math inline">\(|m_p\rangle\)</span>가 정규화되었다고 가정하면(<span class="math inline">\(\langle m_p|m_p\rangle=1\)</span>), <span class="math inline">\(I(x) \propto |\psi_1|^2 + |\psi_2|^2 + 2\text{Re}(\mu \psi_1^*\psi_2)\)</span> 입니다. <span class="math inline">\(\mu=0\)</span>이면(직교 표식), <span class="math inline">\(\psi_1^*\psi_2\)</span> 항이 0이 되어 간섭이 사라집니다.</li>
<li><span class="math inline">\(I(x|e) \propto |\psi_1(x)\langle e|m_1\rangle + \psi_2(x)\langle e|m_2\rangle|^2\)</span>. 간섭항은 <span class="math inline">\(2\text{Re}(\psi_1^*\psi_2 \langle m_1|e\rangle \langle e|m_2\rangle)\)</span>입니다. 이 항이 살아남으려면 <span class="math inline">\(\langle e|m_1\rangle\)</span>과 <span class="math inline">\(\langle e|m_2\rangle\)</span>가 둘 다 0이 아니어야 합니다. 최대 간섭을 위해서는 <span class="math inline">\(|\langle e|m_1\rangle| = |\langle e|m_2\rangle|\)</span> 여야 합니다.</li>
<li>BS 행렬 <span class="math inline">\(U_{BS} = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 &amp; i \\ i &amp; 1 \end{pmatrix}\)</span>, 거울 <span class="math inline">\(U_M = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\)</span>, 위상 <span class="math inline">\(U_\phi = \begin{pmatrix} e^{i\phi_1} &amp; 0 \\ 0 &amp; e^{i\phi_2} \end{pmatrix}\)</span>.
<ul>
<li>BS2 제거: D1 확률은 경로 1만, D2 확률은 경로 2만. 각각 50% (위상차 무관).</li>
<li>BS2 삽입: <span class="math inline">\(U_{BS} U_\phi U_{BS} |0\rangle\)</span>을 계산하면, D1 확률은 <span class="math inline">\(\cos^2(\Delta\phi/2)\)</span>, D2 확률은 <span class="math inline">\(\sin^2(\Delta\phi/2)\)</span> (<span class="math inline">\(\Delta\phi = \phi_2-\phi_1+\pi/2\)</span> 등)로 간섭이 나타납니다.</li>
</ul></li>
<li>지연선택에서 ‘BS2 삽입’과 ’BS2 제거’는 서로 다른 실험 설정을 의미합니다. 각 설정에서 얻은 <em>전체</em> 데이터 분포는 다릅니다. 양자 지우개에서는 <em>전체</em> 데이터(모든 Idler 측정 결과 포함)는 ’지우개’ 설정과 무관하게 항상 동일한 (간섭 없는) 분포를 보입니다. ‘지우개’ 측정은 이 전체 데이터 중 특정 부분집합을 <em>분류</em>하는 기준을 나중에 제공할 뿐이며, 이미 기록된 개별 광자 데이터를 바꾸지 않습니다. 따라서 인과 역행은 없습니다.</li>
<li>보어의 상보성은 ’파동’과 ’입자’라는 고전적 그림에 집착할 때 모순처럼 보입니다. 하지만 지연선택/지우개 실험은 “측정 장치의 전체 설정(Context)”이 우리가 최종적으로 얻는 “통계적 현상”을 결정한다는 것을 보여줍니다. BS2를 삽입하는 설정은 ’간섭 통계’를, BS2를 제거하는 설정은 ’경로 통계’를 산출하도록 설계된 것입니다. 광자가 BS1을 지날 때 ’무엇’이었는지는 중요하지 않으며, 전체 실험 장치(광원, BS1, 경로, BS2/지우개, 검출기)가 하나의 통합된 시스템으로서 최종 통계를 결정한다는 점에서 상보성과 완벽하게 양립합니다.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./7장.일관성_역사와_양자적_확률.html" class="pagination-link" aria-label="7.일관성 역사">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">7.일관성 역사</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./9장.양자다원주의_객관적_실재는_어떻게_탄생하는가.html" class="pagination-link" aria-label="9.양자다원주의">
        <span class="nav-page-text"><span class="chapter-title">9.양자다원주의</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>